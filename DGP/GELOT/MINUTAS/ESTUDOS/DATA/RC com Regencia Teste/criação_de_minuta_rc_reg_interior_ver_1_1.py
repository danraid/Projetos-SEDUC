# -*- coding: utf-8 -*-
"""Criação de Minuta RC REG Interior Ver.1.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16AOVq-o-IQ7LEdHcsrQSQMCAC83hscTG
"""

# Instalar as bibliotecas necessárias
!pip install --quiet python-docx openpyxl pyexcel-xls

import pandas as pd
from docx import Document

def extrair_mapping(df, linha=0):
    """
    Extrai os valores da linha (default=0) de cada coluna do DataFrame.
    Se houver NaN, retorna string vazia.
    Retorna um dicionário: {nome_coluna: valor_str}
    """
    mapping_local = {}
    if len(df) == 0:
        return mapping_local
    for col in df.columns:
        valor = df[col].iloc[linha]
        if pd.isnull(valor):
            valor = ""
        mapping_local[col.strip()] = str(valor).strip()
    return mapping_local

# 2. Leitura dos arquivos Excel originais
# HEAD.xlsx e RODAPE.xlsx são arquivos XLSX; usamos o openpyxl
head_df = pd.read_excel('/content/HEAD.xlsx', engine='openpyxl')
rodape_df = pd.read_excel('/content/RODAPE.xlsx', engine='openpyxl')

# 3. Leitura do novo arquivo RC REG INTERIOR.xlsx
rc_reg_interior_df = pd.read_excel('/content/RC REG INTERIOR.xlsx', engine='openpyxl')

# O arquivo "corpo RC com Reg Interior.xls"
corpo_df = pd.read_excel('/content/corpo RC com Reg Interior.xlsx', engine='openpyxl')

# 3. Extrair os mappings (usando a primeira linha; ajuste o índice se necessário)
mapping_head   = extrair_mapping(head_df)
mapping_corpo  = extrair_mapping(corpo_df)
mapping_rodape = extrair_mapping(rodape_df)
mapping_rc_reg = extrair_mapping(rc_reg_interior_df)

print(">>> Colunas em RC REG INTERIOR.xlsx:", rc_reg_interior_df.columns.tolist())
print(">>> mapping_rc_reg extraído:", mapping_rc_reg, "\n")

# 4. Consolida os mappings originais (prioridade: HEAD -> CORPO -> RODAPE)
mapping = {}
mapping.update(mapping_head)
mapping.update(mapping_corpo)
mapping.update(mapping_rodape)

# 5. Atualiza as colunas do grupo B com os dados da planilha RC REG INTERIOR.xlsx
# Mapeamento: chave do grupo B para o nome da coluna em RC REG INTERIOR.xlsx
colunas_b_mapping = {
    "B5": "MUNICIPIO LOCAL",
    "B6": "NOME LOCAL",
    "B7.1": "SOLICITADO NOME",
    "B7.3": "SOLICITADO MAT-CFPP",
    "B7.5": "TOTAL DE HORAS",
    "B7.7": "COMPONENTE 1",    # Removemos espaços extras
    "B7.9": "TURNO ACRESCIMO",
    "B7.11": "DATA INI.",
    "B7.13": "DATA FIM"
}

# Para cada coluna do grupo B, sobrescreve com o valor da planilha RC REG INTERIOR, se disponível.
for col, rc_key in colunas_b_mapping.items():
    # Usamos strip() para evitar problemas com espaços
    rc_key = rc_key.strip()
    if rc_key in mapping_rc_reg and mapping_rc_reg[rc_key]:
        mapping[col] = mapping_rc_reg[rc_key]
    # Se não houver valor na planilha RC REG INTERIOR, mantém o que já existe (ou vazio)
    else:
        mapping[col] = mapping.get(col, "")

# 6. Define a ordem das colunas originais (concatenando a ordem dos arquivos)
refs = list(head_df.columns) + list(corpo_df.columns) + list(rodape_df.columns)

# 7. Agrupa as colunas por prefixo (parte antes do ponto)
grouped = {}
order = []
for col in refs:
    # O prefixo é a parte antes do ponto; se não houver ponto, usa o nome inteiro
    prefix = col.split('.')[0].strip()
    if prefix not in grouped:
        grouped[prefix] = []
        order.append(prefix)
    # Adiciona o texto correspondente (se existir)
    valor_col = mapping.get(col.strip(), "")
    if valor_col:
        grouped[prefix].append(valor_col)

# Se algum grupo não tiver nenhum valor, define como string vazia
for prefix in grouped:
    if not grouped[prefix]:
        grouped[prefix] = [""]

# 8. Cria o documento Word com a tabela
doc = Document()

# Cria a tabela com 2 colunas: "Texto" e "Referência"
table = doc.add_table(rows=1, cols=2)
hdr_cells = table.rows[0].cells
hdr_cells[0].text = 'Texto'
hdr_cells[1].text = 'Referência'

# Para cada grupo (na ordem de aparição), concatena os textos e adiciona uma linha
for prefix in order:
    texto_agrupado = " ".join(grouped[prefix])
    row_cells = table.add_row().cells
    row_cells[0].text = texto_agrupado
    row_cells[1].text = prefix

# 9. Salva o documento Word
doc.save('output.docx')
print("Arquivo output.docx gerado com sucesso!")