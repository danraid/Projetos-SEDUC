# -*- coding: utf-8 -*-
"""AUTOMAÇÃO DE HORÁRIOS ESCOLA ver.2.0 de 04.03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GxlDFFzBKhnpULNWcE9AUPFmgQR2ECRf
"""

#2.0: import pdfplumber, regex, etc. (mesmo que antes, sem alteração)
!pip install -qq pdfplumber openpyxl regex

import pdfplumber
import regex
import pandas as pd
from google.colab import files

uploaded = files.upload()
pdf_path = list(uploaded.keys())[0]  # nome do arquivo PDF
print("PDF carregado:", pdf_path)

extracted_data = []

servidor_regex = (
    r"^([\p{L}'\s\.]+)"   # Nome do servidor (caracteres UNICODE, espaços, etc.)
    r"\s+"
    r"(MAT|VES)"          # Turno
    r"\s+(\d{2})"         # CH do servidor
    r"\s+(\d{11,})$"      # Código SI (11+ dígitos)
)

mvh_regex = (
    r"Matric\.\:\s+([\d\-A-Z]+)\s+"   # Matrícula
    r"VINCULO\:\s+([A-Z])\s+"        # Vínculo
    r"Hab\.\:\s+(.+)$"               # Habilitação (resto da linha)
)

disc_pattern = (
    r"(0\d{2}\s[\p{L}]+)\s+(\d{2})\s+(\d{2})\s+(\d{4,})\s+([\p{L}]+)\s+(\d+)"
)

# =============================================================
# 5) LER O PDF COMO UM TODO E CRIAR UMA ÚNICA LISTA DE LINHAS
# =============================================================
#2.0: Substituímos a lógica de "for page in pdf.pages" por uma leitura global.
all_lines = []  #2.0
with pdfplumber.open(pdf_path) as pdf:  #2.0
    for page in pdf.pages:  #2.0
        text = page.extract_text()  #2.0
        if text:  #2.0
            page_lines = text.split("\n")  #2.0
            all_lines.extend(page_lines)  #2.0

#2.0: Agora passamos a analisar 'all_lines' de uma só vez.
lines = all_lines  #2.0

i = 0  #2.0
while i < len(lines):  #2.0
    line = lines[i].strip()  #2.0

    match_servidor = regex.match(servidor_regex, line, flags=regex.IGNORECASE)  #2.0
    if match_servidor:  #2.0
        nome_servidor = match_servidor.group(1).strip()  #2.0
        turno = match_servidor.group(2).strip()  #2.0
        ch_servidor = match_servidor.group(3).strip()  #2.0
        codigo_si = match_servidor.group(4).strip()  #2.0

        matricula = ""
        vinculo = ""
        habilitacao = ""

        if (i + 1) < len(lines):  #2.0
            line_next = lines[i + 1].strip()  #2.0
            mvh_match = regex.search(mvh_regex, line_next)  #2.0
            if mvh_match:  #2.0
                matricula = mvh_match.group(1).strip()  #2.0
                vinculo = mvh_match.group(2).strip()  #2.0
                habilitacao = mvh_match.group(3).strip()  #2.0

        j = i + 2
        while j < len(lines):  #2.0
            line_disc = lines[j].strip()  #2.0

            # Se linha de separador ou outro servidor, paramos este bloco
            if line_disc.startswith("---"):  #2.0
                break
            if regex.match(servidor_regex, line_disc, flags=regex.IGNORECASE):  #2.0
                break

            disc_matches = regex.findall(disc_pattern, line_disc)  #2.0
            if disc_matches:  #2.0
                for dm in disc_matches:  #2.0
                    ensino      = dm[0]
                    serie_ano   = dm[1]
                    turma       = dm[2]
                    cod_disc    = dm[3]
                    nome_disc   = dm[4]
                    ch_turma    = dm[5]

                    extracted_data.append({
                        "SERVIDOR": nome_servidor,
                        "TURNO": turno,
                        "CH": ch_servidor,
                        "MATRICULA": matricula,
                        "VINCULO": vinculo,
                        "HABILITACAO": habilitacao,
                        "ENSINO": ensino,
                        "SERIE/ANO": serie_ano,
                        "TURMA": turma,
                        "COD.DISC": cod_disc,
                        "DISC": nome_disc,
                        "CH.TURMA": ch_turma
                    })

            j += 1

        i = j  #2.0
    else:
        i += 1  #2.0

# =============================================================
# 6) CONVERTER LISTA DE DICIONÁRIOS EM DATAFRAME
# =============================================================
df = pd.DataFrame(extracted_data)

# =============================================================
# 7) SEPARAR "ENSINO" EM "COD.ESCOLA" e "NIVEL"
# =============================================================
df[["COD.ESCOLA", "NIVEL"]] = df["ENSINO"].str.split(n=1, expand=True)
df.drop(columns=["ENSINO"], inplace=True)

colunas_finais = [
    "SERVIDOR",
    "TURNO",
    "CH",
    "MATRICULA",
    "VINCULO",
    "HABILITACAO",
    "COD.ESCOLA",
    "NIVEL",
    "SERIE/ANO",
    "TURMA",
    "COD.DISC",
    "DISC",
    "CH.TURMA"
]
df = df[colunas_finais]

df["CH"] = pd.to_numeric(df["CH"], errors="coerce").astype("Int64")
df["CH.TURMA"] = pd.to_numeric(df["CH.TURMA"], errors="coerce").astype("Int64")

df.head(20)

saida_excel = "saida_final.xlsx"
df.to_excel(saida_excel, index=False)
print(f"Planilha gerada: {saida_excel}")

# =============================================================
# EXEMPLO DE CRIAÇÃO DE OUTRA PLANILHA COM COLUNAS SEG, TER, ETC.
# =============================================================
df_filtered = df[['SERVIDOR', 'TURNO']].drop_duplicates()

dias_semana = ['SEG', 'TER', 'QUA', 'QUI', 'SEX']
for dia in dias_semana:
    for k in range(1, 6):
        df_filtered[f"{dia}{k}"] = 0

output_file = "/content/professores.xlsx"
df_filtered.to_excel(output_file, index=False)
df_filtered.head(20)