# -*- coding: utf-8 -*-
"""QUADRO_HORÁRIOS_VER_2_7_5_2 DE_03_03_25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GxE3u_ei7RPu5fQYJF4ylBYaaxw_ylNQ
"""

import pandas as pd
import random
import math
import copy
from collections import defaultdict, namedtuple

# =========================================================================
# PARÂMETROS GERAIS
# =========================================================================
dias_semana = ["SEG", "TER", "QUA", "QUI", "SEX"]
tempos = [1, 2, 3, 4, 5]
NUM_ITERACOES_HEUR = 1000    # número de iterações da busca inicial (GRASP)
NUM_ITERACOES_SA = 1000   # número de iterações do Simulated Annealing (SA)

# =========================================================================
# 1) LEITURA DOS ARQUIVOS
# =========================================================================
df_prof = pd.read_excel("professores.xlsx")
df_demanda_raw = pd.read_excel("demanda.xlsx")  # Demanda vem do arquivo "demanda.xlsx"

# =========================================================================
# 2) CRIAR DICIONÁRIO DE DISPONIBILIDADE
#    disponib[prof][turno][dia][tempo] = True/False
# =========================================================================
disponib = {}
for i, row in df_prof.iterrows():
    servidor = row["SERVIDOR"]
    turno    = row["TURNO"]
    if servidor not in disponib:
        disponib[servidor] = {}
    if turno not in disponib[servidor]:
        disponib[servidor][turno] = {}
    for d in dias_semana:
        if d not in disponib[servidor][turno]:
            disponib[servidor][turno][d] = {}
        for t in tempos:
            col = f"{d}{t}"  # Ex.: SEG1, SEG2, ..., SEX5
            if col in row:
                val = row[col]
                disponib[servidor][turno][d][t] = (val == 1)
            else:
                disponib[servidor][turno][d][t] = False

# =========================================================================
# 3) FILTRAR "APOIO" E MONTAR DEMANDA
# =========================================================================
df_demand = df_demanda_raw[df_demanda_raw["DISC"] != "APOIO"].copy()
Pedido = namedtuple("Pedido", "prof turno nivel serie turma disc ch")
demanda = []
for i, row in df_demand.iterrows():
    demanda.append(Pedido(
        prof  = row["SERVIDOR"],
        turno = row["TURNO"],
        nivel = row["NIVEL"],
        serie = str(row["SERIE/ANO"]),
        turma = str(row["TURMA"]),
        disc  = row["DISC"],
        ch    = int(row["CH"])
    ))

# =========================================================================
# 4) ESTRUTURA DE ALOCAÇÃO
#    horario[turno][nivel][dia][(serie, turma)] = { tempo: (prof, disc) }
# =========================================================================
def cria_horario_vazio(demanda):
    """Gera a estrutura vazia para todos os (turno, nivel, dia, serie, turma) presentes na demanda."""
    horario = {}
    combos = set()
    for ped in demanda:
        combos.add((ped.turno, ped.nivel))
    for (tnr, niv) in combos:
        if tnr not in horario:
            horario[tnr] = {}
        if niv not in horario[tnr]:
            horario[tnr][niv] = {}
        for d in dias_semana:
            horario[tnr][niv][d] = {}
    for ped in demanda:
        for d in dias_semana:
            if (ped.serie, ped.turma) not in horario[ped.turno][ped.nivel][d]:
                horario[ped.turno][ped.nivel][d][(ped.serie, ped.turma)] = {}
    return horario

# =========================================================================
# 5A) FUNÇÕES DE VERIFICAÇÃO DAS RESTRIÇÕES
# =========================================================================
def professor_disponivel(prof, turno, dia, tempo):
    if prof not in disponib:
        return False
    if turno not in disponib[prof]:
        return False
    return disponib[prof][turno][dia][tempo]

def professor_ocupado_esse_tempo(horario, prof, turno, niv, dia, tempo):
    for (_, dicT) in horario[turno][niv][dia].items():
        if tempo in dicT:
            (p, _) = dicT[tempo]
            if p == prof:
                return True
    return False

def turma_ja_tem_aula(horario, turno, niv, dia, serie, turma, tempo):
    return (tempo in horario[turno][niv][dia][(serie, turma)])

def check_buraco(horario, ped, dia):
    dicT = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    if not dicT:
        return False
    tempos_ocup = sorted(dicT.keys())
    if tempos_ocup[0] != 1:
        return True
    maxi = max(tempos_ocup)
    for x in range(1, maxi+1):
        if x not in dicT:
            return True
    return False

def professor_turma_ja_usou_dia(horario, ped, dia):
    """Evita que o mesmo professor seja alocado mais de uma vez por dia na mesma turma."""
    dicTurma = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    for (tm, (p, _)) in dicTurma.items():
        if p == ped.prof:
            return True
    return False

def alocar_1tempo(horario, ped, dia, tempo):
    horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)][tempo] = (ped.prof, ped.disc)

def desalocar_1tempo(horario, ped, dia, tempo):
    dicTurma = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    if tempo in dicTurma:
        del dicTurma[tempo]

def check_professor_gap(horario, prof, turno, dia):
    """
    Verifica se o professor 'prof' possui buracos na grade no 'dia' e 'turno' especificados.
    Retorna True se houver gap, False se a alocação for contínua ou se houver 0 ou 1 aula.
    """
    allocated_times = []
    for niv in horario[turno]:
        for (_, turma), dic in horario[turno][niv][dia].items():
            for t, (p, _) in dic.items():
                if p == prof:
                    allocated_times.append(t)
    if len(allocated_times) <= 1:
        return False
    allocated_times = sorted(allocated_times)
    for i in range(len(allocated_times) - 1):
        if allocated_times[i+1] - allocated_times[i] > 1:
            return True
    return False

def pode_alocar(horario, ped, dia, tempo):
    """Verifica todas as restrições antes de alocar."""
    if not professor_disponivel(ped.prof, ped.turno, dia, tempo):
        return False
    if professor_ocupado_esse_tempo(horario, ped.prof, ped.turno, ped.nivel, dia, tempo):
        return False
    if professor_turma_ja_usou_dia(horario, ped, dia):
        return False
    # Testa alocação temporária para checar se gera buraco na turma
    alocar_1tempo(horario, ped, dia, tempo)
    if check_buraco(horario, ped, dia):
        desalocar_1tempo(horario, ped, dia, tempo)
        return False
    # NOVA RESTRIÇÃO: verifica se a alocação gera gap na grade do professor
    if check_professor_gap(horario, ped.prof, ped.turno, dia):
        desalocar_1tempo(horario, ped, dia, tempo)
        return False
    desalocar_1tempo(horario, ped, dia, tempo)  # Remove a alocação teste
    return True

# =========================================================================
# 5B) FUNÇÃO PARA CALCULAR CARGA HORÁRIA ALOCADA POR SERVIDOR
# =========================================================================
def calcula_carga_horaria_alocada(horario):
    carga_horaria = defaultdict(int)
    for turno in horario:
        for nivel in horario[turno]:
            for dia in dias_semana:
                for (_, turma), tempos_dict in horario[turno][nivel][dia].items():
                    for tempo, (prof, _) in tempos_dict.items():
                        carga_horaria[prof] += 1
    print("\nCarga Horária Alocada por Servidor:")
    for prof, horas in sorted(carga_horaria.items(), key=lambda x: x[1], reverse=True):
        print(f"{prof}: {horas} aulas")

# =========================================================================
# FUNÇÕES DE PENALIDADE PARA RESTRIÇÕES SOFT
# =========================================================================
def calcula_penalidades(horario, demanda):
    # Pesos para restrições soft
    peso_alocacao_extra = 50    # penalidade para mais de uma alocação por dia na mesma turma para o mesmo professor
    peso_gap_prof = 0          # 2.7.5: reduzido de 50 para 0 para penalizar menos gaps no horário do professor

    penalidade_total = 0

    # Penaliza alocações extras na mesma turma para o mesmo professor no mesmo dia
    for ped in demanda:
        for d in dias_semana:
            contagem = 0
            for niv in horario[ped.turno]:
                turma_aloc = horario[ped.turno][niv][d].get((ped.serie, ped.turma), {})
                for t, (p, _) in turma_aloc.items():
                    if p == ped.prof:
                        contagem += 1
            if contagem > 1:
                penalidade_total += peso_alocacao_extra * (contagem - 1)

    # Penaliza gaps na grade do professor
    for prof in disponib.keys():
        for turno in disponib[prof]:
            for d in dias_semana:
                allocated_times = []
                for niv in horario[turno]:
                    for (_, turma), dic in horario[turno][niv][d].items():
                        for t, (p, _) in dic.items():
                            if p == prof:
                                allocated_times.append(t)
                if len(allocated_times) > 1:
                    allocated_times = sorted(allocated_times)
                    for i in range(len(allocated_times)-1):
                        if allocated_times[i+1] - allocated_times[i] > 1:
                            penalidade_total += peso_gap_prof
    return penalidade_total

def score_solucao_com_penalidades(horario, demanda):
    usados = conta_alocacoes(horario)
    slots = total_slots_ideal(demanda)
    gaps_turma = total_gaps(horario)  # Considerado "hard" para a turma
    nao_aloc = sum(p.ch for p in demanda) - usados

    peso_gap_turma = 1000  # Penalidade alta para gaps na turma
    penalidade_soft = calcula_penalidades(horario, demanda)
    # -------------------------------------------------------------------------
    # 2.7.5.2 - Ajuste de penalização para não alocados (incentiva + alocação)
    # -------------------------------------------------------------------------
    # (linha original):
    # score = usados - peso_gap_turma * gaps_turma - 250 * nao_aloc - penalidade_soft
    # (modificamos para 200 em vez de 250)
    score = usados - peso_gap_turma * gaps_turma - 200 * nao_aloc - penalidade_soft  #2.7.5.2

    feats = {
        "usados": usados,
        "slots": slots,
        "gaps": gaps_turma,
        "nao_alocados": nao_aloc,
        "penalidades_soft": penalidade_soft,
        "percent_filled": (usados / slots) * 100 if slots else 0
    }
    return score, feats

# =========================================================================
# 6A) GERAÇÃO DE SOLUÇÕES INICIAIS (GRASP) COM CONSTRUÇÃO GULOSA ORDENADA 2.7.5
# =========================================================================
def alocar_demanda(horario, demanda):
    nao_alocados = []
    # Ordena os pedidos por carga horária (maiores primeiro)
    dem_local = sorted(demanda, key=lambda p: p.ch, reverse=True)

    for ped in dem_local:
        ch_rest = ped.ch

        # --------------------------------------------------------------------
        # 2.7.5.2 - Embaralhamos a ordem de dias e/ou tempos a cada pedido
        # --------------------------------------------------------------------
        dias_rand = copy.deepcopy(dias_semana)  #2.7.5.2
        random.shuffle(dias_rand)               #2.7.5.2
        tempos_rand = copy.deepcopy(tempos)     #2.7.5.2
        random.shuffle(tempos_rand)             #2.7.5.2

        for d in dias_rand:      #2.7.5.2
            if ch_rest <= 0:
                break
            for t in tempos_rand:  #2.7.5.2
                if ch_rest <= 0:
                    break
                if pode_alocar(horario, ped, d, t):
                    alocar_1tempo(horario, ped, d, t)
                    ch_rest -= 1

        if ch_rest > 0:
            nao_alocados.append((ped, ch_rest))
    return nao_alocados

def constroi_solucao(demanda):
    hor_temp = cria_horario_vazio(demanda)
    nao_aloc = alocar_demanda(hor_temp, demanda)
    return hor_temp, nao_aloc

# =========================================================================
# 6B) EXTRAÇÃO DE FEATURES E AVALIAÇÃO
# =========================================================================
def conta_alocacoes(horario):
    used = 0
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    used += len(dic)
    return used

def total_slots_ideal(demanda):
    """Cada turma tem 25 slots (5 dias x 5 tempos)."""
    turmas = set((ped.serie, ped.turma) for ped in demanda)
    return len(turmas) * 25

def total_gaps(horario):
    gaps = 0
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    if dic:
                        tempos_ocup = sorted(dic.keys())
                        maxi = max(tempos_ocup)
                        for t in range(1, maxi+1):
                            if t not in dic:
                                gaps += 1
    return gaps

def extrair_features(horario, demanda):
    usados = conta_alocacoes(horario)
    slots = total_slots_ideal(demanda)
    gaps = total_gaps(horario)
    nao_aloc = sum(p.ch for p in demanda) - usados
    percent_filled = (usados / slots) * 100 if slots else 0
    return {
        "usados": usados,
        "slots": slots,
        "gaps": gaps,
        "nao_alocados": nao_aloc,
        "percent_filled": percent_filled
    }

def score_solucao(horario, demanda):
    # Versão antiga, mantida para comparação se necessário
    feats = extrair_features(horario, demanda)
    score = feats["usados"] - 2 * feats["gaps"] - 5 * feats["nao_alocados"]
    return score, feats

# =========================================================================
# 6C) GERAÇÃO DAS MELHORES SOLUÇÕES INICIAIS (GRASP)
# =========================================================================
N_BEST = 10
solucoes = []  # lista para armazenar (horario, nao_alocados, score, features)
for i in range(NUM_ITERACOES_HEUR):
    hor_cand, nao_aloc_cand = constroi_solucao(demanda)
    score, feats = score_solucao_com_penalidades(hor_cand, demanda)
    solucoes.append((hor_cand, nao_aloc_cand, score, feats))
# Ordena pelas melhores pontuações (maior score)
solucoes.sort(key=lambda x: x[2], reverse=True)
best_solucoes = solucoes[:N_BEST]

print("Melhores soluções iniciais (GRASP):")
for idx, sol in enumerate(best_solucoes, 1):
    print(f"  Solução {idx}: Score = {sol[2]}")

# Seleciona a melhor solução GRASP (antes do SA)
best_grasp, best_nao_aloc, best_score_grasp, feats_grasp = best_solucoes[0]

print("Resultado após GRASP:")
print(f"Melhor Score GRASP: {best_score_grasp}")
usados_grasp = conta_alocacoes(best_grasp)
total_grasp = total_slots_ideal(demanda)
percent_grasp = (usados_grasp / total_grasp) * 100 if total_grasp else 0
print(f"Slots usados: {usados_grasp}")
print(f"Slots vazios: {total_grasp - usados_grasp}")
print(f"Percentual de preenchimento: {percent_grasp:.2f}%")
print("----------------------------------------------")

# =========================================================================
# 6D) REFINAMENTO COM SIMULATED ANNEALING (SA)
# =========================================================================
# ------------------------------------------------------------------------------
# 2.7.5.2 - nova função auxiliar para remover 1 hora alocada e devolver ao "nao_alocados"
# ------------------------------------------------------------------------------
def remover_tempo_aleatorio(horario):  #2.7.5.2
    """Remove um tempo aleatório do horário, retornando (pedido_resto, dia, tempo) ou None se não houver nada alocado."""  #2.7.5.2
    alocados = []
    # Coletar todos os slots alocados
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    for tm, (prof, disc) in dic.items():
                        # Precisamos descobrir qual 'Pedido' corresponde (prof, tnr, niv, ser, tur, disc)
                        alocados.append((tnr, niv, d, ser, tur, tm, prof, disc))
    if not alocados:
        return None

    (tnr, niv, d, ser, tur, tm, prof, disc) = random.choice(alocados)

    # Remove do horário
    del horario[tnr][niv][d][(ser, tur)][tm]

    # Precisamos criar algo que represente 1 hora "devolvida" ao pedido original
    pedido_falso = Pedido(prof=prof, turno=tnr, nivel=niv, serie=ser, turma=tur, disc=disc, ch=1)
    return pedido_falso, d, tm


def simulated_annealing(horario, nao_alocados, demanda, num_iter, T0=500.0, alpha=0.999):
    current_hor = copy.deepcopy(horario)
    current_nao = copy.deepcopy(nao_alocados)
    current_score, _ = score_solucao_com_penalidades(current_hor, demanda)

    best_hor = copy.deepcopy(current_hor)
    best_nao = copy.deepcopy(current_nao)
    best_score = current_score

    T = T0
    for i in range(num_iter):
        new_hor = copy.deepcopy(current_hor)
        new_nao = copy.deepcopy(current_nao)

        # ----------------------------------------------------------------------
        # 2.7.5.2 - Tipo de movimento: com probabilidade 50%, remove 1 tempo alocado e depois tenta realocar
        # ----------------------------------------------------------------------
        if random.random() < 0.5:  #2.7.5.2
            remov = remover_tempo_aleatorio(new_hor)  #2.7.5.2
            if remov is not None:                     #2.7.5.2
                (pedido_falso, d_rem, t_rem) = remov  #2.7.5.2
                # Devolve essa 1h "falsa" ao nao_alocados
                new_nao.append((pedido_falso, 1))     #2.7.5.2

        # Movimento básico: tenta alocar CH de pedidos não atendidos
        if new_nao:
            idx = random.choice(range(len(new_nao)))
            ped, ch_rest = new_nao[idx]
            allocated = False
            # Tenta alocar
            dias_rand = copy.deepcopy(dias_semana)   #2.7.5.2
            random.shuffle(dias_rand)                #2.7.5.2
            tempos_rand = copy.deepcopy(tempos)      #2.7.5.2
            random.shuffle(tempos_rand)              #2.7.5.2

            for d in dias_rand:         #2.7.5.2
                if ch_rest <= 0:
                    break
                for t in tempos_rand:   #2.7.5.2
                    if ch_rest <= 0:
                        break
                    if pode_alocar(new_hor, ped, d, t):
                        alocar_1tempo(new_hor, ped, d, t)
                        ch_rest -= 1
                        allocated = True
                        break
                if allocated:
                    break
            if ch_rest == 0:
                new_nao.pop(idx)
            else:
                new_nao[idx] = (ped, ch_rest)

        new_score, _ = score_solucao_com_penalidades(new_hor, demanda)
        delta = new_score - current_score
        if delta > 0 or random.random() < math.exp(delta / T):
            current_hor = new_hor
            current_nao = new_nao
            current_score = new_score
            if new_score > best_score:
                best_hor = copy.deepcopy(new_hor)
                best_nao = copy.deepcopy(new_nao)
                best_score = new_score

        T *= alpha
    return best_hor, best_nao

refined_solucoes = []
for hor, nao_aloc, score_init, feats_init in best_solucoes:
    new_hor, new_nao = simulated_annealing(hor, nao_aloc, demanda, NUM_ITERACOES_SA, T0=100.0, alpha=0.99)
    score_ref, feats_ref = score_solucao_com_penalidades(new_hor, demanda)
    refined_solucoes.append((new_hor, new_nao, score_ref, feats_ref))

refined_solucoes.sort(key=lambda x: x[2], reverse=True)
melhor_refinado, melhor_nao_alocados, melhor_score_ref, feats_refin = refined_solucoes[0]

print("Resultado após refinamento com SA:")
print(f"Melhor Score Refinado: {melhor_score_ref}")
usados_final = conta_alocacoes(melhor_refinado)
total_final = total_slots_ideal(demanda)
percent_filled = (usados_final / total_final) * 100 if total_final else 0
print(f"Slots usados: {usados_final}")
print(f"Slots vazios: {total_final - usados_final}")
print(f"Percentual de preenchimento: {percent_filled:.2f}%")
print("----------------------------------------------")

# =========================================================================
# CÓDIGO ADICIONAL: RESUMO DA ALOCAÇÃO DE CH POR SERVIDOR
# =========================================================================
# Calcula o total de CH demandado por servidor (soma dos pedidos)
total_CH_por_servidor = {}
for ped in demanda:
    total_CH_por_servidor[ped.prof] = total_CH_por_servidor.get(ped.prof, 0) + ped.ch

# Calcula a CH alocada em cada slot do melhor horário refinado
CH_alocada_por_servidor = {}
for tnr in melhor_refinado:
    for niv in melhor_refinado[tnr]:
        for d in dias_semana:
            for (serie, turma), dic in melhor_refinado[tnr][niv][d].items():
                for t in dic:
                    prof, _ = dic[t]
                    CH_alocada_por_servidor[prof] = CH_alocada_por_servidor.get(prof, 0) + 1

# Monta o resumo com a CH demandada, alocada e o saldo (não alocado)
resumo_CH = []
for prof in total_CH_por_servidor:
    total_demandado = total_CH_por_servidor[prof]
    alocada = CH_alocada_por_servidor.get(prof, 0)
    nao_alocada = total_demandado - alocada
    resumo_CH.append({
        "Servidor": prof,
        "Total CH Demandado": total_demandado,
        "CH Alocada": alocada,
        "CH Não Alocada": nao_alocada
    })

df_resumo_CH = pd.DataFrame(resumo_CH)
total_linha = {
    "Servidor": "TOTAL",
    "Total CH Demandado": df_resumo_CH["Total CH Demandado"].sum(),
    "CH Alocada": df_resumo_CH["CH Alocada"].sum(),
    "CH Não Alocada": df_resumo_CH["CH Não Alocada"].sum()
}
df_total = pd.DataFrame([total_linha])
df_resumo_CH = pd.concat([df_resumo_CH, df_total], ignore_index=True)

print("Resumo da alocação de CH por servidor:")
print(df_resumo_CH)

# =========================================================================
# 6E) SALVAR FEATURES EXTRAÍDAS (para uso em ML futuro)
# =========================================================================
df_features = pd.DataFrame([{"Score": sol[2], **sol[3]} for sol in refined_solucoes])
df_features.to_excel("FEATURES_SOLUCOES.xlsx", index=False)

# =========================================================================
# 7) EXPORTAÇÃO FINAL DOS RESULTADOS
#    (A) Quadro de Horários por Turma (abas por (TURNO, NIVEL))
#    (B) Quadro de Horários por Professor (aba por professor)
#    (C) Lista Detalhada dos Slots Vazios
# =========================================================================
def gera_df_por_turma(horario):
    colunas_por_tn = defaultdict(set)
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    colunas_por_tn[(tnr, niv)].add(f"{ser}-{tur}")
    dfs_por_aba = {}
    for tnr in horario:
        for niv in horario[tnr]:
            turmas_cols = sorted(list(colunas_por_tn[(tnr, niv)]))
            linhas = []
            for d in dias_semana:
                for tm in tempos:
                    row_dict = {"TURNO": tnr, "NIVEL": niv, "DIA": d, "TEMPO": tm}
                    for col in turmas_cols:
                        row_dict[col] = ""
                    for (ser, tur), dic in horario[tnr][niv][d].items():
                        if tm in dic:
                            (p, ds) = dic[tm]
                            colname = f"{ser}-{tur}"
                            row_dict[colname] = f"{p}+{ds}"
                    linhas.append(row_dict)
            df_aba = pd.DataFrame(linhas)
            dfs_por_aba[f"{tnr}_{niv}"] = df_aba
    return dfs_por_aba

def gera_df_por_professor(horario):
    prof_data = defaultdict(lambda: defaultdict(list))
    prof_cols = defaultdict(set)
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    for tm, (p, ds) in dic.items():
                        col = f"{ser}-{tur}({ds})"
                        prof_cols[p].add(col)
                        prof_data[p][(d, tm)].append((tnr, niv, ser, tur, ds))
    dfs_por_prof = {}
    for p in prof_data:
        cols = sorted(list(prof_cols[p]))
        linhas = []
        for d in dias_semana:
            for tm in tempos:
                row_dict = {"PROFESSOR": p, "DIA": d, "TEMPO": tm}
                for c in cols:
                    row_dict[c] = ""
                if (d, tm) in prof_data[p]:
                    for (tnr, niv, ser, tur, ds) in prof_data[p][(d, tm)]:
                        cname = f"{ser}-{tur}({ds})"
                        row_dict[cname] = f"{tnr}-{niv}"
                linhas.append(row_dict)
        df_p = pd.DataFrame(linhas)
        dfs_por_prof[p] = df_p
    return dfs_por_prof

dfs_turma = gera_df_por_turma(melhor_refinado)
dfs_prof = gera_df_por_professor(melhor_refinado)

with pd.ExcelWriter("QUADRO_HORÁRIOS_TURMAS.xlsx") as writer:
    for aba, df_ in dfs_turma.items():
        df_.to_excel(writer, sheet_name=aba[:31], index=False)

with pd.ExcelWriter("QUADRO_HORÁRIOS_PROFESSORES.xlsx") as writer:
    for p, df_ in dfs_prof.items():
        sheetname = p[:31]
        df_.to_excel(writer, sheet_name=sheetname, index=False)

vazios_detalhe = []
for tnr in melhor_refinado:
    for niv in melhor_refinado[tnr]:
        for d in dias_semana:
            for (ser, tur), dic in melhor_refinado[tnr][niv][d].items():
                for tm in tempos:
                    if tm not in dic:
                        vazios_detalhe.append({
                            "TURNO": tnr,
                            "NIVEL": niv,
                            "DIA": d,
                            "SERIE": ser,
                            "TURMA": tur,
                            "TEMPO": tm
                        })

df_vaz = pd.DataFrame(vazios_detalhe)
df_vaz.to_excel("NAO_ALOCADOS_TEMPOS_VAZIOS.xlsx", index=False)

print("Arquivos gerados:")
print(" - QUADRO_HORÁRIOS_TURMAS.xlsx (abas por Turno_Nível)")
print(" - QUADRO_HORÁRIOS_PROFESSORES.xlsx (abas por professor)")
print(" - NAO_ALOCADOS_TEMPOS_VAZIOS.xlsx (lista detalhada dos slots vazios)")
print(" - FEATURES_SOLUCOES.xlsx (features de cada iteração)")