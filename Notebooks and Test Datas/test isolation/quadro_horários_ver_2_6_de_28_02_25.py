# -*- coding: utf-8 -*-
"""QUADRO_HORÁRIOS_VER_2_6_DE_28_02_25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NEGSsIQ9TczyAthMKhJAyannxi8PfFTw
"""

import pandas as pd
import random
from collections import defaultdict, namedtuple

# =========================================================================
# PARÂMETROS GERAIS
# =========================================================================
dias_semana = ["SEG", "TER", "QUA", "QUI", "SEX"]
tempos = [1, 2, 3, 4, 5]
NUM_ITERACOES_HEUR = 1000    # número de iterações da busca heurística inicial
NUM_ITERACOES_REFIN = 500      # número de iterações do ajuste fino

# =========================================================================
# 1) LEITURA DOS ARQUIVOS
# =========================================================================
df_prof = pd.read_excel("professores.xlsx")
df_demanda_raw = pd.read_excel("demanda.xlsx")  # Demanda vem do arquivo "demanda.xlsx"

# =========================================================================
# 2) CRIAR DICIONÁRIO DE DISPONIBILIDADE
#    disponib[prof][turno][dia][tempo] = True/False
# =========================================================================
disponib = {}
for i, row in df_prof.iterrows():
    servidor = row["SERVIDOR"]
    turno    = row["TURNO"]
    if servidor not in disponib:
        disponib[servidor] = {}
    if turno not in disponib[servidor]:
        disponib[servidor][turno] = {}
    for d in dias_semana:
        if d not in disponib[servidor][turno]:
            disponib[servidor][turno][d] = {}
        for t in tempos:
            col = f"{d}{t}"  # Ex.: SEG1, SEG2, ..., SEX5
            if col in row:
                val = row[col]
                disponib[servidor][turno][d][t] = (val == 1)
            else:
                disponib[servidor][turno][d][t] = False

# =========================================================================
# 3) FILTRAR "APOIO" E MONTAR DEMANDA
# =========================================================================
df_demand = df_demanda_raw[df_demanda_raw["DISC"] != "APOIO"].copy()
Pedido = namedtuple("Pedido", "prof turno nivel serie turma disc ch")
demanda = []
for i, row in df_demand.iterrows():
    demanda.append(Pedido(
        prof  = row["SERVIDOR"],
        turno = row["TURNO"],
        nivel = row["NIVEL"],
        serie = str(row["SERIE/ANO"]),
        turma = str(row["TURMA"]),
        disc  = row["DISC"],
        ch    = int(row["CH.TURMA"])
    ))

# =========================================================================
# 4) ESTRUTURA DE ALOCAÇÃO
#    horario[turno][nivel][dia][(serie, turma)] = { tempo: (prof, disc) }
# =========================================================================
def cria_horario_vazio(demanda):
    """Gera a estrutura vazia para todos os (turno, nivel, dia, serie, turma) presentes na demanda."""
    horario = {}
    combos = set()
    for ped in demanda:
        combos.add((ped.turno, ped.nivel))
    for (tnr, niv) in combos:
        if tnr not in horario:
            horario[tnr] = {}
        if niv not in horario[tnr]:
            horario[tnr][niv] = {}
        for d in dias_semana:
            horario[tnr][niv][d] = {}
    for ped in demanda:
        for d in dias_semana:
            if (ped.serie, ped.turma) not in horario[ped.turno][ped.nivel][d]:
                horario[ped.turno][ped.nivel][d][(ped.serie, ped.turma)] = {}
    return horario

# =========================================================================
# 5) FUNÇÕES DE VERIFICAÇÃO DAS RESTRIÇÕES
# =========================================================================
def professor_disponivel(prof, turno, dia, tempo):
    if prof not in disponib:
        return False
    if turno not in disponib[prof]:
        return False
    return disponib[prof][turno][dia][tempo]

def professor_ocupado_esse_tempo(horario, prof, turno, niv, dia, tempo):
    for (st, dicT) in horario[turno][niv][dia].items():
        if tempo in dicT:
            (p, _) = dicT[tempo]
            if p == prof:
                return True
    return False

def turma_ja_tem_aula(horario, turno, niv, dia, serie, turma, tempo):
    return (tempo in horario[turno][niv][dia][(serie, turma)])

def check_buraco(horario, ped, dia):
    dicT = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    if not dicT:
        return False
    tempos_ocup = sorted(dicT.keys())
    if tempos_ocup[0] != 1:
        return True
    maxi = max(tempos_ocup)
    for x in range(1, maxi+1):
        if x not in dicT:
            return True
    return False

def professor_turma_ja_usou_dia(horario, ped, dia):
    """Evita que o mesmo professor seja alocado mais de uma vez por dia na mesma turma."""
    dicTurma = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    for (tm, (p, _)) in dicTurma.items():
        if p == ped.prof:
            return True
    return False

def alocar_1tempo(horario, ped, dia, tempo):
    horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)][tempo] = (ped.prof, ped.disc)

def desalocar_1tempo(horario, ped, dia, tempo):
    dicTurma = horario[ped.turno][ped.nivel][dia][(ped.serie, ped.turma)]
    if tempo in dicTurma:
        del dicTurma[tempo]

def pode_alocar(horario, ped, dia, tempo):
    """Verifica todas as restrições antes de alocar."""
    if not professor_disponivel(ped.prof, ped.turno, dia, tempo):
        return False
    if professor_ocupado_esse_tempo(horario, ped.prof, ped.turno, ped.nivel, dia, tempo):
        return False
    if professor_turma_ja_usou_dia(horario, ped, dia):
        return False
    # Testa alocação temporária para checar se gera buraco
    alocar_1tempo(horario, ped, dia, tempo)
    if check_buraco(horario, ped, dia):
        desalocar_1tempo(horario, ped, dia, tempo)
        return False
    desalocar_1tempo(horario, ped, dia, tempo)  # Remove a alocação teste
    return True

# =========================================================================
# 6A) BUSCA HEURÍSTICA INICIAL
# =========================================================================
def alocar_demanda(horario, demanda):
    nao_alocados = []
    dem_local = list(demanda)
    random.shuffle(dem_local)
    for ped in dem_local:
        ch_rest = ped.ch
        dias_rand = list(dias_semana)
        random.shuffle(dias_rand)
        for d in dias_rand:
            if ch_rest <= 0:
                break
            tempos_rand = list(tempos)
            random.shuffle(tempos_rand)
            for t in tempos_rand:
                if ch_rest <= 0:
                    break
                if pode_alocar(horario, ped, d, t):
                    alocar_1tempo(horario, ped, d, t)
                    ch_rest -= 1
        if ch_rest > 0:
            nao_alocados.append((ped, ch_rest))
    return nao_alocados

def constroi_solucao(demanda):
    hor_temp = cria_horario_vazio(demanda)
    nao_aloc = alocar_demanda(hor_temp, demanda)
    return hor_temp, nao_aloc

# =========================================================================
# 6B) EXTRAÇÃO DE FEATURES E AVALIAÇÃO
# =========================================================================
def conta_alocacoes(horario):
    used = 0
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    used += len(dic)
    return used

def total_slots_ideal(demanda):
    """Cada turma tem 25 slots (5 dias x 5 tempos)."""
    turmas = set((ped.serie, ped.turma) for ped in demanda)
    return len(turmas) * 25

def total_gaps(horario):
    gaps = 0
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    if dic:
                        tempos_ocup = sorted(dic.keys())
                        maxi = max(tempos_ocup)
                        for t in range(1, maxi+1):
                            if t not in dic:
                                gaps += 1
    return gaps

def extrair_features(horario, demanda):
    usados = conta_alocacoes(horario)
    slots = total_slots_ideal(demanda)
    gaps = total_gaps(horario)
    nao_aloc = sum(p.ch for p in demanda) - usados
    percent_filled = (usados / slots) * 100 if slots else 0
    return {
        "usados": usados,
        "slots": slots,
        "gaps": gaps,
        "nao_alocados": nao_aloc,
        "percent_filled": percent_filled
    }

def score_solucao(horario, demanda):
    feats = extrair_features(horario, demanda)
    score = feats["usados"] - 2 * feats["gaps"] - 5 * feats["nao_alocados"]
    return score, feats

# =========================================================================
# 6C) ITERAÇÃO E APURAMENTO: BUSCA HEURÍSTICA COM EXTRAÇÃO DE FEATURES
# =========================================================================
melhor_horario = None
melhor_nao_alocados = None
melhor_score = -float("inf")
features_iter = []
for i in range(NUM_ITERACOES_HEUR):
    hor_cand, nao_aloc_cand = constroi_solucao(demanda)
    score, feats = score_solucao(hor_cand, demanda)
    features_iter.append((score, feats))
    if score > melhor_score:
        melhor_score = score
        melhor_horario = hor_cand
        melhor_nao_alocados = nao_aloc_cand

print("Resultado da busca heurística inicial:")
print(f"Melhor Score: {melhor_score}")
feats_heur = extrair_features(melhor_horario, demanda)
print(f"Features: {feats_heur}")

# =========================================================================
# 6D) AJUSTE FINO (REFINEMENT)
#    Agora, para cada pedido não totalmente alocado, a cada tentativa de alocação
#    é chamado pode_alocar(horario, ped, dia, tempo) para revalidar restrições,
#    e ch_rest é decrementado, sem permitir realocar o mesmo pedido além do CH.TURMA.
# =========================================================================
def ajuste_fino(horario, nao_alocados):
    novos_nao = []
    for ped, ch_rest in nao_alocados:
        # Tenta alocar para cada pedido, utilizando somente dias onde o professor ainda não foi alocado na turma
        for d in dias_semana:
            if ch_rest <= 0:
                break
            # Só tenta se o professor não foi alocado neste dia para essa turma
            if professor_turma_ja_usou_dia(horario, ped, d):
                continue
            for t in tempos:
                if ch_rest <= 0:
                    break
                if pode_alocar(horario, ped, d, t):
                    alocar_1tempo(horario, ped, d, t)
                    ch_rest -= 1
        if ch_rest > 0:
            novos_nao.append((ped, ch_rest))
    return horario, novos_nao

if any(c > 0 for (_, c) in melhor_nao_alocados):
    print("Aplicando ajuste fino para encaixar os tempos remanescentes...")
    for _ in range(NUM_ITERACOES_REFIN):
        melhor_horario, novos_nao = ajuste_fino(melhor_horario, melhor_nao_alocados)
        nova_sobra = sum(x[1] for x in novos_nao)
        if nova_sobra < sum(x[1] for x in melhor_nao_alocados):
            melhor_nao_alocados = novos_nao
    score_refin, feats_refin = score_solucao(melhor_horario, demanda)
else:
    score_refin, feats_refin = score_solucao(melhor_horario, demanda)

print("Resultado após ajuste fino:")
print(f"Score Refinado: {score_refin}")
usados_final = conta_alocacoes(melhor_horario)
total_final = total_slots_ideal(demanda)
percent_filled = (usados_final / total_final) * 100 if total_final else 0
print(f"Slots usados: {usados_final}")
print(f"Slots vazios: {total_final - usados_final}")
print(f"Percentual de preenchimento: {percent_filled:.2f}%")
print("----------------------------------------------")

# =========================================================================
# 6E) SALVAR FEATURES EXTRAÍDAS (para uso em ML futuro)
# =========================================================================
df_features = pd.DataFrame([{"Score": s, **f} for s, f in features_iter])
df_features.to_excel("FEATURES_SOLUCOES.xlsx", index=False)

# =========================================================================
# 7) EXPORTAÇÃO FINAL DOS RESULTADOS
#    (A) Quadro de Horários por Turma (abas por (TURNO, NIVEL))
#    (B) Quadro de Horários por Professor (aba por professor)
#    (C) Lista Detalhada dos Slots Vazios
# =========================================================================
def gera_df_por_turma(horario):
    colunas_por_tn = defaultdict(set)
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    colunas_por_tn[(tnr, niv)].add(f"{ser}-{tur}")
    dfs_por_aba = {}
    for tnr in horario:
        for niv in horario[tnr]:
            turmas_cols = sorted(list(colunas_por_tn[(tnr, niv)]))
            linhas = []
            for d in dias_semana:
                for tm in tempos:
                    row_dict = {"TURNO": tnr, "NIVEL": niv, "DIA": d, "TEMPO": tm}
                    for col in turmas_cols:
                        row_dict[col] = ""
                    for (ser, tur), dic in horario[tnr][niv][d].items():
                        if tm in dic:
                            (p, ds) = dic[tm]
                            colname = f"{ser}-{tur}"
                            row_dict[colname] = f"{p}+{ds}"
                    linhas.append(row_dict)
            df_aba = pd.DataFrame(linhas)
            dfs_por_aba[f"{tnr}_{niv}"] = df_aba
    return dfs_por_aba

def gera_df_por_professor(horario):
    prof_data = defaultdict(lambda: defaultdict(list))
    prof_cols = defaultdict(set)
    for tnr in horario:
        for niv in horario[tnr]:
            for d in dias_semana:
                for (ser, tur), dic in horario[tnr][niv][d].items():
                    for tm, (p, ds) in dic.items():
                        col = f"{ser}-{tur}({ds})"
                        prof_cols[p].add(col)
                        prof_data[p][(d, tm)].append((tnr, niv, ser, tur, ds))
    dfs_por_prof = {}
    for p in prof_data:
        cols = sorted(list(prof_cols[p]))
        linhas = []
        for d in dias_semana:
            for tm in tempos:
                row_dict = {"PROFESSOR": p, "DIA": d, "TEMPO": tm}
                for c in cols:
                    row_dict[c] = ""
                if (d, tm) in prof_data[p]:
                    for (tnr, niv, ser, tur, ds) in prof_data[p][(d, tm)]:
                        cname = f"{ser}-{tur}({ds})"
                        row_dict[cname] = f"{tnr}-{niv}"
                linhas.append(row_dict)
        df_p = pd.DataFrame(linhas)
        dfs_por_prof[p] = df_p
    return dfs_por_prof

dfs_turma = gera_df_por_turma(melhor_horario)
dfs_prof = gera_df_por_professor(melhor_horario)

with pd.ExcelWriter("QUADRO_HORÁRIOS_TURMAS.xlsx") as writer:
    for aba, df_ in dfs_turma.items():
        df_.to_excel(writer, sheet_name=aba[:31], index=False)

with pd.ExcelWriter("QUADRO_HORÁRIOS_PROFESSORES.xlsx") as writer:
    for p, df_ in dfs_prof.items():
        sheetname = p[:31]
        df_.to_excel(writer, sheet_name=sheetname, index=False)

vazios_detalhe = []
for tnr in melhor_horario:
    for niv in melhor_horario[tnr]:
        for d in dias_semana:
            for (ser, tur), dic in melhor_horario[tnr][niv][d].items():
                for tm in tempos:
                    if tm not in dic:
                        vazios_detalhe.append({
                            "TURNO": tnr,
                            "NIVEL": niv,
                            "DIA": d,
                            "SERIE": ser,
                            "TURMA": tur,
                            "TEMPO": tm
                        })
df_vaz = pd.DataFrame(vazios_detalhe)
df_vaz.to_excel("NAO_ALOCADOS_TEMPOS_VAZIOS.xlsx", index=False)

print("Arquivos gerados:")
print(" - QUADRO_HORÁRIOS_TURMAS.xlsx (abas por Turno_Nível)")
print(" - QUADRO_HORÁRIOS_PROFESSORES.xlsx (abas por professor)")
print(" - NAO_ALOCADOS_TEMPOS_VAZIOS.xlsx (lista detalhada dos slots vazios)")
print(" - FEATURES_SOLUCOES.xlsx (features de cada iteração)")